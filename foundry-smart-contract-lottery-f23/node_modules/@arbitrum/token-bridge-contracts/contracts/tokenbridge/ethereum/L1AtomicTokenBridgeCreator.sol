// SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8.4;

import {
    L1TokenBridgeRetryableSender,
    L1DeploymentAddresses,
    RetryableParams,
    L2TemplateAddresses,
    IERC20Inbox,
    IERC20,
    SafeERC20
} from "./L1TokenBridgeRetryableSender.sol";
import {L1GatewayRouter} from "./gateway/L1GatewayRouter.sol";
import {L1ERC20Gateway} from "./gateway/L1ERC20Gateway.sol";
import {L1CustomGateway} from "./gateway/L1CustomGateway.sol";
import {L1WethGateway} from "./gateway/L1WethGateway.sol";
import {L1OrbitGatewayRouter} from "./gateway/L1OrbitGatewayRouter.sol";
import {L1OrbitERC20Gateway} from "./gateway/L1OrbitERC20Gateway.sol";
import {L1OrbitCustomGateway} from "./gateway/L1OrbitCustomGateway.sol";
import {
    L2AtomicTokenBridgeFactory,
    CanonicalAddressSeed,
    OrbitSalts,
    L2RuntimeCode,
    ProxyAdmin
} from "../arbitrum/L2AtomicTokenBridgeFactory.sol";
import {CreationCodeHelper} from "../libraries/CreationCodeHelper.sol";
import {BytesLib} from "../libraries/BytesLib.sol";
import {
    IUpgradeExecutor,
    UpgradeExecutor
} from "@offchainlabs/upgrade-executor/src/UpgradeExecutor.sol";
import {AddressAliasHelper} from "../libraries/AddressAliasHelper.sol";
import {IInbox, IBridge, IOwnable} from "@arbitrum/nitro-contracts/src/bridge/IInbox.sol";
import {AddressAliasHelper} from "../libraries/AddressAliasHelper.sol";
import {ArbMulticall2} from "../../rpc-utils/MulticallV2.sol";
import {BeaconProxyFactory, ClonableBeaconProxy} from "../libraries/ClonableBeaconProxy.sol";
import {Create2} from "@openzeppelin/contracts/utils/Create2.sol";
import {
    Initializable,
    OwnableUpgradeable
} from "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import {TransparentUpgradeableProxy} from
    "@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol";
import {IAccessControlUpgradeable} from
    "@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol";

/**
 * @title Layer1 token bridge creator
 * @notice This contract is used to deploy token bridge on custom L2 chains.
 * @dev Throughout the contract terms L1 and L2 are used, but those can be considered as base (N) chain and child (N+1) chain
 */
contract L1AtomicTokenBridgeCreator is Initializable, OwnableUpgradeable {
    using SafeERC20 for IERC20;

    error L1AtomicTokenBridgeCreator_OnlyRollupOwner();
    error L1AtomicTokenBridgeCreator_InvalidRouterAddr();
    error L1AtomicTokenBridgeCreator_TemplatesNotSet();
    error L1AtomicTokenBridgeCreator_RollupOwnershipMisconfig();
    error L1AtomicTokenBridgeCreator_ProxyAdminNotFound();
    error L1AtomicTokenBridgeCreator_L2FactoryCannotBeChanged();

    event OrbitTokenBridgeCreated(
        address indexed inbox,
        address indexed owner,
        address router,
        address standardGateway,
        address customGateway,
        address wethGateway,
        address proxyAdmin,
        address upgradeExecutor
    );
    event OrbitTokenBridgeTemplatesUpdated();
    event NonCanonicalRouterSet(address indexed inbox, address indexed router);

    struct L1Templates {
        L1GatewayRouter routerTemplate;
        L1ERC20Gateway standardGatewayTemplate;
        L1CustomGateway customGatewayTemplate;
        L1WethGateway wethGatewayTemplate;
        L1OrbitGatewayRouter feeTokenBasedRouterTemplate;
        L1OrbitERC20Gateway feeTokenBasedStandardGatewayTemplate;
        L1OrbitCustomGateway feeTokenBasedCustomGatewayTemplate;
        IUpgradeExecutor upgradeExecutor;
    }

    // non-canonical router registry
    mapping(address => address) public inboxToNonCanonicalRouter;

    // Hard-code gas to make sure gas limit is big enough for L2 factory deployment to succeed.
    // If retryable would've reverted due to too low gas limit, nonce 0 would be burned and
    // canonical address for L2 factory would've been unobtainable
    uint256 public gasLimitForL2FactoryDeployment;

    // contract which creates retryables for deploying L2 side of token bridge
    L1TokenBridgeRetryableSender public retryableSender;

    // L1 logic contracts shared by all token bridges
    L1Templates public l1Templates;

    // L2 contracts deployed to L1 as bytecode placeholders
    address public l2TokenBridgeFactoryTemplate;
    address public l2RouterTemplate;
    address public l2StandardGatewayTemplate;
    address public l2CustomGatewayTemplate;
    address public l2WethGatewayTemplate;
    address public l2WethTemplate;

    // WETH address on L1
    address public l1Weth;

    // Multicall2 address on L1, this should NOT be ArbMulticall2
    address public l1Multicall;

    // immutable canonical address for L2 factory
    // other canonical addresses (dependent on L2 template implementations) can be fetched through `getCanonicalL2***Address` functions
    address public canonicalL2FactoryAddress;

    // immutable ArbMulticall2 template deployed 